import importlib.resources
import os
import stat
import sys
from pathlib import Path

from autodoc.utils.logger import setup_logger

logger = setup_logger()


def init_project():
    """
    Installs the git hook in the current repository.
    """
    hook_path = Path(".git/hooks/post-commit")

    if not Path(".git").exists():
        logger.error("Not a git repository. Run 'git init' first.")
        return

    logger.info(f"Installing post-commit hook to {hook_path}...")

    # Strategy: Lock in the current interpreter path
    # This ensures consistency across OS (Windows/Linux) and Venv types (Conda/Poetry/Standard)
    # The user runs 'autodoc init' from their active environment, so we use that one.
    python_exe = sys.executable

    # On Windows, paths might need escaping, but for shell scripts (Git Bash) / forward slashes usually work.
    # We'll use a specific cross-platform compatible approach if possible,
    # but for now, raw sys.executable is the most robust single-source-of-truth.

    hook_content = f"""#!/bin/sh
# Auto-Doc Hook
# Generated by 'autodoc init'
# Locked to Python Environment: {python_exe}

"{python_exe}" -m autodoc.hooks.post_commit
if [ $? -ne 0 ]; then
    echo "❌ Auto-Doc Hook Failed."
fi
"""

    try:
        hook_path.write_text(hook_content, encoding="utf-8")
        # Make executable
        st = os.stat(hook_path)
        os.chmod(hook_path, st.st_mode | stat.S_IEXEC)
        logger.info("✅ Hook installed successfully.")
    except Exception as e:
        logger.error(f"Failed to install hook: {e}")

    # 2. Create Default Templates
    templates_dir = Path(".autodoc/templates")
    templates_dir.mkdir(parents=True, exist_ok=True)

    # A. System Instruction
    sys_path = templates_dir / "system_instruction.j2"
    if not sys_path.exists():
        content = _get_package_template("system_instruction.j2")
        sys_path.write_text(content, encoding="utf-8")

    # B. Doc Prompt
    prompt_path = templates_dir / "doc_prompt.j2"
    if not prompt_path.exists():
        # Map default_prompt.j2 (internal) to doc_prompt.j2 (user)
        content = _get_package_template("default_prompt.j2")
        prompt_path.write_text(content, encoding="utf-8")

    # 3. Create Default Config
    config_path = Path(".autodoc/config.yaml")

    if not config_path.exists():
        logger.info(f"Creating default config at {config_path}...")
        config_content = """# Auto-Doc Configuration

# Global Context
context:
  files:
    - "README.md"

# Mappings: source globs -> target docs
mappings:
  - name: "Main API"
    source: "src/**/*.py"
    doc: "docs/reference.md"

# Templates
# Paths to your custom Jinja2 templates
prompt_template: ".autodoc/templates/doc_prompt.j2"
system_instruction_template: ".autodoc/templates/system_instruction.j2"

# Model Configuration
model: "gemini-3-flash-preview"
thinking_level: "high"
"""
        try:
            config_path.write_text(config_content, encoding="utf-8")
            logger.info("✅ Config created successfully.")
        except Exception as e:
            logger.error(f"Failed to create config: {e}")
    else:
        logger.info(f"ℹ️  Config file already exists at {config_path}")


def _get_package_template(name: str) -> str:
    """Retrieves content of a template file from the package source."""
    try:
        # Modern python >= 3.9
        ref = importlib.resources.files("autodoc.templates") / name
        return ref.read_text(encoding="utf-8")
    except Exception as e:
        logger.warning(f"Failed to load package template {name} via importlib: {e}")
        # Fallback for dev mode
        base_dir = Path(__file__).resolve().parent.parent / "templates"
        template_path = base_dir / name
        if template_path.exists():
            return template_path.read_text(encoding="utf-8")
        return f"# Error loading template: {name}"
